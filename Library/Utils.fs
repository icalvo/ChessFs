module Utils

    module Option =
        let defaultTo defValue opt = defaultArg opt defValue
        let pipe action = Option.map (fun x -> action x; x)
        let mapList fn opt =
            opt
            |> Option.map fn 
            |> defaultTo []

    module Seq =
        let pipe action = Seq.map (fun x -> action x; x)
        let debug name = pipe (fun x -> if Configuration.debug then printfn $"%s{name} yields %A{x}")
        let filterNones (s: seq<'a option>): seq<'a> = Seq.choose id s
        let takeWhileIncludingLast predicate (s:seq<_>) = 
            /// Iterates over the enumerator, yielding elements and
            /// stops after an element for which the predicate does not hold
            let rec loop (en:System.Collections.Generic.IEnumerator<_>) = seq {
                if en.MoveNext() then
                    // Always yield the current, stop if predicate does not hold
                    yield en.Current
                    if predicate en.Current then
                        yield! loop en }

            // Get enumerator of the sequence and yield all results
            // (making sure that the enumerator gets disposed)
            seq { use en = s.GetEnumerator()
                yield! loop en }

        /// <summary>
        /// Returns a sequence that contains the elements generated by the given computation.
        /// </summary>
        /// <param name="nextFn"></param>
        /// <remarks>Works as Seq.unfold, but in this version the State and returned element are the same.
        /// Therefore, the generator function has the signature:
        ///     'State -> 'State option
        /// </remarks>
        let unfoldSimple nextFn =
            nextFn >> Option.map (fun x -> (x, x)) |> Seq.unfold

        /// Returns a sequence that yields chunks of length n.
        /// Each chunk is returned as a list.
        let batch length (xs: seq<'T>) =
            let rec loop xs =
                [
                    yield Seq.truncate length xs |> Seq.toList
                    match Seq.length xs <= length with
                    | false -> yield! loop (Seq.skip length xs)
                    | true -> ()
                ]
            loop xs

    module List =
        let pipe action = List.map (fun x -> action x; x)
        let debug name = pipe (printfn "%s yields %A" name)
        let apply arg fnlist = fnlist |> List.map (fun fn -> fn arg)
        let filterNones (s: 'a option list): 'a list = List.choose id s

    type Result<'a> = 
    | Success of 'a
    | Failure of 'a * string list

    module Result = 

        let map f xResult = 
            match xResult with
            | Success x ->
                Success (f x)
            | Failure (x, err) ->
                Failure (f x, err)
        // Signature: ('a -> 'b) -> Result<'a> -> Result<'b>

        // "return" is a keyword in F#, so abbreviate it
        let retn x = 
            Success x
        // Signature: 'a -> Result<'a>

        let apply fResult xResult = 
            match fResult,xResult with
            | Success f, Success x ->
                Success (f x)
            | Failure (f, errs), Success x ->
                Failure (f x, errs)
            | Success f, Failure (x, errs) ->
                Failure (f x, errs)
            | Failure (f, errs1), Failure (x, errs2) ->
                // concat both lists of errors
                Failure (f x, List.concat [errs1; errs2])
        // Signature: Result<('a -> 'b)> -> Result<'a> -> Result<'b>

        let bind f xResult = 
            match xResult with
            | Success x ->
                f x
            | Failure (x, errs) ->
                match f x with
                | Success b -> Failure (b, errs)
                | Failure (b, errsb) -> Failure (b, List.concat [errs; errsb])

        let defaultWith successFunc failureFunc result =
            match result with
            | Success x -> successFunc x
            | Failure (x, err) -> failureFunc x err

    let (>?>) f1 f2 = f1 >> Option.bind f2

    let rec (*) f1 i =
        if i = 1 then f1 else f1 >> Option.bind (f1 * (i-1))

    module Map =
        let keys map = map |> Map.toList |> List.map (fun (k, _) -> k)
        let values map = map |> Map.toList |> List.map (fun (_, v) -> v)